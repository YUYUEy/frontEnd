#### 什么是并发？  

**先来理解为什么会有并发这个概念**  

由于硬件条件的限制，内存 外存这些设备的处理速度和cpu比起来慢的多。所以就可以用一个cpu在同一段时间运行多个任务。  
主要的原理是依靠于任务的快速切换。  

这种在同一个时间段内运行多个程序的能力就是并发。有三种模型--进程 线程 协程，这三种模型在本质上都是依靠上面说的  
那样子工作的。  

要想学好计算机，对抽象的这个概念必须有一个特别好的认识。进程 线程 协程就是这样的一种被抽象出来的东西。  

#### 进程 线程 协程间的区别？

本质上的原理都是差不多的，很大的一个区别是这三种模型的粒度不同。先不考虑这三者的具体实现，先从使用者这个角度来看这三者  

**进程**  

进程这个模型是比较“重”的一种模型，在使用的时候耗费的资源会比较多。  

**线程**  

线程比进程轻一个级别，可以开启较大量的线程。  
还有一点是线程并不是只用来提升性能的，试想在一个应用中 一个线程处理gui界面，一个线程处理网络，一个处理输入。。。  
这就需要一种 共享的地址空间和所有可用数据的能力，这个就要靠线程来实现。（进程也可以实现，但是使用进程会很麻烦）

**协程**  

本质上协程就是用户态的线程，比线程更轻量一些（因为不需要陷入内核，不需要对内存高速缓存刷新）  
在python中还有GIL的存在，python中使用协程不会受GIL影响。
拿tcp链接来说，使用协程，每条链接耗费的资源很少，可以开大量的链接。  
  
而问题在于处理阻塞是个问题，线程依靠系统来处理阻塞，不会出现一个线程阻塞掉一个进程的情况。  
缺点主要也就是在这里，用的不好很容易把程序写烂。  
![Case见这里](https://github.com/zhao94254/fun/blob/master/os/case/ademo.py)   

**在Python中使用**  

python中有GIL的存在，多线程在cpu密集任务上会很惨。

    Io密集任务对比： 
        对百度访问十次
        normal: 2.7963725133368125
		async: 0.259026675203911
		threaded: 0.3700776957651426
    
    Cpu 密集任务：  
        为了使对比更明显一点，对fib中的每个递归函数开一个线程  
        
        def fib_threaded(x):
			if x in (0, 1):
				return 1
			a, b = pool.map(fib_threaded, (x-2, x-1))
			return a + b
			
		Normal: 0.02296766084507665
		async: 0.05889395842593638
		Threaded: 6.648548444782004

**对比**  

![对比图](http://pyblog-10073407.image.myqcloud.com/postimage1501896672?imageView2/0/w/450/h/400 "enter image title here")

**python中 线程 协程 进程的应用场景**  

    CPU密集型任务 比如科学计算。。使用线程和协程是累赘，应该使用进程池
	如果一个应用中，多个模块需要同步处理的时候，比如GUI 线程就是一个比较好的选择。
	web方面
	少量客户端 短连接  线程 协程
	少量客户端 长连接  线程 协程
	大量客户端 短连接  协程 或者 线程池
	大量客户端 长连接  协程
	再具体来说是 
	任何高IO密集，同时CPU耗费少的任务都是使用协程。如果连接并没有特别多使用线程会更好。
	

**Goroutine**  

用户空间线程 和 内核空间线程中间的映射关系有三种：  

      N:1 多个线程在一个内核线程跑  无法真正利用多核（类似于多个人一个桌子吃饭。）
      1:1 一个线程在一个内核线程跑  上下文切换慢 （一个人在一个桌子吃饭）
      N:M  多个线程在多个内核线程跑   （多个人在多个桌子吃饭）
     

Goroutine 使用的就是 N:M 的模式，go调度器内部有三种结构。  

M P G 其中M是真正的内核os线程 P是调度的上下文 G是goroutine 有自己的栈 和一些其他信息   

可能会维持多个上下文，这是因为当一个M被阻塞的时候，P可以使用其它M，保证有足够多的M来跑P  

拿餐厅服务员送菜来举例。M相当于是一个服务员 P相当于是一个送餐的车 G是要送的东西   

试想 如果服务员比较少，而餐车很多的时候，就可以添加服务员来送餐。 当产生一个要送的东西G    
就把它加入到餐车P中。等待真正处理的M来处理。

更多可见 https://www.zhihu.com/question/20862617



上面提到了Go的，下面简单说下python的   
     
python常用的模型是  多个协程---一个线程---一个进程 也就是上面说的N:1的模式     
使用多核的话就只能一个核部署一个进程使用，这样子会耗费不少内存。


  


	
	
	
	
	
	
	
	
	
	