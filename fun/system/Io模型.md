#### 明确几个概念  
**同步 异步 阻塞 非阻塞**  
很多人有的一个错误的概念是把异步和非阻塞搞混。其实同步和异步 与 阻塞和非阻塞关注的完全是两个东西。  

 举例来说：  
 你去买本书，书店老板说这个书暂时没有，你可以选择主动在书店等书来（这就是同步）  
  或者是先做其他的等书到了老板给打电话（这就是异步）。  
  同步和异步关注的是这个对象本身是主动还是被动的去等待这个结果。  
  而阻塞 非阻塞关注的是等待这个结果时候的状态。   
  比如：一直在等书来，中间什么也不做。（阻塞）    
  做其他的事，时不时看看书来了没。（非阻塞）  
  
#### 常用的io模型  

阻塞IO  
![阻塞IO](http://pyblog-10073407.image.myqcloud.com/postimage1513041595?imageView2/0/w/450/h/400)  
阻塞io就是当前进程一直在等待io响应，当响应不返回就一直在当前位置等待。  

非阻塞IO  
![非阻塞IO](http://pyblog-10073407.image.myqcloud.com/postimage1513041599?imageView2/0/w/450/h/400)
上图时一种轮训的模型，需要时不时去看是否有数据准备好了。  

信号驱动IO  
![信号驱动](http://pyblog-10073407.image.myqcloud.com/postimage1513041592?imageView2/0/w/450/h/400)

当一个io时间发生时，请求直接返回。只有当数据到达时，通过信号来告诉应用程序，将数据拷贝到应用缓冲。  


IO复用（select poll epoll）  
![io复用](http://pyblog-10073407.image.myqcloud.com/postimage1513041601?imageView2/0/w/450/h/400)  
io复用是阻塞在select 或者 poll 或者 epoll 上，类似于拨片开关，可以同时处理很多条链接。

异步IO（aio）  
![异步io](http://pyblog-10073407.image.myqcloud.com/postimage1513041587?imageView2/0/w/450/h/400)

和上面信号驱动的区别在于异步io是通知我们io操作何时完成的。信号驱动告诉我们的时io操作何时开始。  

**select poll epoll 区别**  

**select**

    select 的实现思路：  
    集合｛1，2，3｝ 中任意一个准备好了读，或者写。
    集合｛1，2，3｝ 中任意一个出现异常。
    超过了设定的时间  满足以上任意一点，就唤醒进程
    
    由于实现的早，主要的缺点是：
    select 会有最大连接数的限制，大多数的系统都是1024
    select 不会告诉具体那一个sock有数据，需要进行查找（线性时间）
    select 不是线程安全的
    select 需要将fd拷贝多次 
    
**poll**

    去掉了最大连接数的限制，通过分配一个pollfd结构的数组来维持信息。对于最大连接数的限制  
    转移到了应用这里（一般无法确定最大的描述字数目，用一个max数来代替）。
    
    和select一样是需要自己去查找sock（线性时间）， 一样不是线程安全的。

**epoll**
    
    只在linux下特有。
    epoll 是线程安全的，对最大链接数没有限制，只关心活跃的链接。
    下面这两点应该是对性能提升最大的点。
    
    会直接将有可读的那个链接返回（O（1）的复杂度），不需要自己去找。
    不需要在用户空间和内核中多次拷贝。
    





![区别](http://pyblog-10073407.image.myqcloud.com/postimage1513042930?imageView2/0/w/450/h/400)


同步io 和 异步 io  

同步io操作引起请求进程阻塞，直到io完成。  
异步io不会使进程阻塞。  

也就是说上面的模型除了最后的异步IO是真正的异步IO。上面的信号驱动的IO可能看起来像异步的IO，但是在读取  
数据的时候是由应用进程阻塞去读取的。  

还要明确一个很重要的一点是这是一个不同层次的问题。比如python中使用的协程配合io复用的操作。在程序中是可以  
在调用接口立马切换到其它的协程执行的。  

通过几个程序来理解：  

见本目录下：  
 
aecho 和 aplay 展示了如何在应用中来实现异步非阻塞。  

























