**从广义的角度上看，Cache是快设备为了缓解访问慢设备延时的预留的Buffer，    
从而可以在掩盖访问延时的同时，尽可能地提高数据传输率。**    

上面是cache的主要作用，我们写程序的时候经常用内存当cache使用，但是在内存上面还有    
L1 L2 L3 cache ，要注意的是cache是一个相对的概念。对于磁盘来说内存是可以当缓存用的。    


#### cache如何工作？    

大部分的cache是分成很多行的，通过一行一行来对应内存中的地址。    
具体的对应的过程是 将逻辑地址 线性地址 物理地址 对应起来。在实际使用的时候    
为了加快变换引入了一个TLB（相当于的页表的cache）用来加快地址转换。    

**cache地址和物理地址的对应方式**   

    直接映射-- 将内存分成和cache line 等份大小的块 一行对应一块  
    看起来简单高效，但是会造成cache miss 率极高，造成颠簸。   
    
    全相联映射-- 每一行对应所有的块
    效率会低，如果找不到要遍历整个cache
    
    N路组相联映射
    上面两种的中和 一组line 对应 一大块内存
    
**Cache为什么有那么多级？是不是Cache越大越好？**
   
    1. L1 cache是为了更快的速度
    2. L2 cache是为了更大的容量
    
    分级是为了在延迟和容量之间取得一个最优解。
    L1 级别的cache 延迟会很小 但是容量也会很小。    
    
    开个脑洞，假设L1 cache现在变成了一个G大小会怎么样？
    L1 cache变的特别大并没有什么用，因为单位时间cpu可以   
    处理的数据就那么多，L1 cache加大并没有什么提升。
    同样的L2 L3 级的cache的大小只要可以
    保证里面的数据够cpu一直在计算就可以。 这也是缓存的主要目的。



#### 如何用好缓存？   

我们写应用的时候更为底层的一些东西就不去考虑了。比如： 把L1 L2 L3 cache中移走的数据放在内存的那里之类的问题。   
    


我们主要考虑什么时候用缓存。  
   
将那些数据放在缓存中。  

如何把缓存中的数据更新到磁盘中。  
   

**什么时候用缓存**   

从一个应用程序员的角度来看，缓存里面放那些要重复读取的数据。比如：   

网站的首页（一般不会轻易的变化，放在缓存中加快读取速度）  
     
    重复使用的数据
    
    def memorize(f):
        """缓存"""
        cache = {}
        @wraps(f)
        def memorized(*args):
            if args not in cache:
                cache[args] = f(*args)
            return cache[args]
        return memorized
    
    @memorize
    def fib(x):
        return x if x < 2 else fib(x-1) + fib(x-2)


**缓存置换的算法**   

缓存都是很小的（相对的一个概念），很多时候无法把所有的数据都放在缓存中，一些数据就要在缓存中换入换出   

常见的缓存置换的算法有 先进先出算法，最近最久未使用算法 最佳置换算法。 使用的时候应该考虑具体的场景。   
有些算法的实现难度比较大 但是性能好，有的实现简单 但是性能可能没那么好。   

先进先出 适用于实效性要求高的场景下    
最近最少使用算法 保证高频数据的有效性的时候可以用这个   
最近最少使用算法 保证热点数据的有效性的时候用这个


**缓存更新**     

Read Through 在查询的时候更新缓存，如果缓存失效 就去数据库拿数据并且放入缓存   

Write Through 在更新数据的时候如果没有命中缓存就直接更新数据库，然后返回。如果命中    
就更新缓存，再让cache更新数据库。（同步）    

Write Behind 更新的时候只更新缓存，然后异步批量更新数据库。 这种方式的优点是io会特别好    
同时可以将多个数据合并操作，更新数据库的速度也非常快。   
缺点是 数据可能不是强一致性，可能会丢失。    


**缓存雪崩**    

如果缓存服务器是一台，这台挂掉。导致请求都打到后台数据库 可能会打垮后台数据库，导致整个网站挂掉。    

解决方法是 再加一台缓存服务器（提升了可用性，分区容忍性 但是放弃了强一致性）。

**缓存穿透**    

请求的某个key对应的数据不存在，并且没缓存，导致一直请求数据库导致数据库挂掉。    

解决方法： 限制频率，对无数据的key添加NULL.设置一个默认值。     

**缓存预热**    

如果系统刚启动，新缓存系统中没数据，就把要放入缓存的数据先添加进来。    



     



    



   





















  


