### 事物


**事物是什么？**

数据系统中可能会出现很多问题（比如硬件可能出问题，网络可能会出问题，多个客户端同时操作一个数据库数据可能会出问题。。），解决这种问题是非常麻烦的一件事情，事物是用来解决数据系统中出错问题的一种手段。 事物简化了这些问题。


A（原子性）C（一致性）I（隔离性）D（持久性） 


* 原子性

这里的原子性指的是在发生错误的时候终止事物，丢弃该事物的写入变更。举例来讲就是一个写操作写数据写到一半的时候出现问题了，这时之前写入的就不要了，直接将整个写入都放弃掉。

* 一致性

这里的一致性是应用程序通过数据库提供的原子性和隔离属性来实现的。讲的是通过事物来将应用从一个一致的状态转到另一个一致的状态。

* 隔离性

隔离性就是并发环境下，并发事物对同一数据的操作是相互隔离的。当事物查看数据的更新的时候要么看到修改前的状态，要么看到修改后的状态。不会看到中间状态的数据。

* 持久性

这里的持久性指的是当事物成功结束，对数据库做的更新就会永久保存。


**弱隔离级别**

并发的程序是很难写的，数据库这一层提供了一层抽象（事物隔离）来隐藏这个问题。可序列化的隔离级别是可以保证事物是串行的，但是这种方式是有性能损失的。
实际的使用中有一些更弱的隔离级别。

**读已提交**

无脏读， 从数据库读取的时候只能看到已经提交的数据
无脏写，数据库写入的时候只会覆盖已经写入的数据

**为什么防止脏读？**

1. 事物更新多个对象的时候，脏读意味着查看更新的时候可能只能看到部分的更新。
2. 如果事物中止，要进行回滚，可能另一个事物会看到需要回滚的数据


**为什么要防止脏写？**

举例来说，有这样一个二手车交易系统，两个用户买同一辆车，购买车的时候需要两次数据库写入，分别是更新车辆表和发票表。可能的一种情况是

    A 和 B同时操作
    A 先更新了车辆表
    B 更新了车辆表
    B 更新了发票表
    A 更新了发票表

这种情况下A用户这里显示的是购买车辆成功，但是没有收到发票，发票发送到了B用户这里。

**如何解决这个问题？**

**行锁** 用来防止脏写，想要对对象进行修改的时候先拿到锁，直到事物提交或者中止再释放锁。在这个锁释放后其它对象才可以对它进行操作。

**读锁** 是防止脏读的一种方式，这种锁可能会因为一个长时间的写入事物而阻塞掉，有可能导致大量操作被阻塞。

另一种方式是保存已经提交的最新值，和尚未提交的新值。当新值提交后返回新的值。

快照隔离和可重复读

不可重复读和读取偏差

上面的读已提交已经防止了很多问题，但是还有一种情况是这样子的：

    A 有两个账户， 账户 1 \ 2， 两个账户分别有500元
    A 将 账户 1 中的100美元转移到 账户2 中
    A 首先查看自己的 账户1 有 500元
    交易员将账户1加上100， 现在是600元
    交易员将账户2减去100， 现在是400元
    A 查看账户2，发现现在是400， 现在整个账户的余额变成了900

当A 再次查看自己的账户1的时候发现是正常的。 在这里有一个短暂的不一致。

解决方法（**快照隔离**）

事物从数据库的一致性快照中读取，事物在开始的时候看到所有的数据，当另一个数据将这些数据修改后，事物也只可以看到特定时间冻结的一致性快照。

实现快照隔离（MVCC多版本并发控制）

从性能上来考虑，读的时候尽量不要阻塞写，写的时候尽量不要阻塞读，这使得数据库处理一些在一致性快照上的长时间查询的时候可以正常处理写入。

使用读已提交的时候，需要保存一个对象的提交的版本和被覆盖但是未被提交的版本。


![enter image description here](http://pyblog-10073407.image.myqcloud.com/postimage1528202151?imageView2/0/w/450/h/400 "enter image title here")


Postgre 中的基于mvcc的快照隔离
created_by 代表将该行插入表中的事务id， deleted_dy 是删除的id，删除的时候通过标记deleted_by的id来进行删除的。

update 操作其实是 delete 和 insert 两个操作

事务id 用来决定可以看到那些对象，通过定义这个可见性的规则 来向应用程序呈现一致的数据库快照。
工作流程如下：

    事物开始时，列出所有的事物清单（中止的和未提交的），之后提交的也被忽略
    中止事物执行的写入被忽略
    在事物开始后的写入被忽略
    其它的写入对应用可见

上述规则适用于删除和创建对象，拿上图来看，事物12从账户2读取看到的是500，在事物13之前完成（规则3，事物开始后的写入被忽略），给用户看的还是500

简言之如下：

* 读的事物开始的时候，创建该对象的事物已经是提交的
* 请求删除的事物在读事物开始时还未被提交


