### DDIA（6）

**分区**

	* 什么是分区
	* 为什么要分区，分区的好处是什么
	* 如何分区
	* 分区时要注意什么



**什么是分区？**

这是一种分而治之的思路，例如要处理一个很大的日志，将所有的日志写在一个文件下肯定是不合适的，这时需要将日志   
按照天，或者星期为维度来保存，这样就是将文件拆分开了。查找时候也更快。  

数据库的分区就是将一个大表拆为多个独立的小表，查询的范围小了，性能也会快很多。

**为什么要分区，分区的好处是什么？**

分区主要是为了可扩展性，可扩展性也是如今的大多数应用最需要考虑的一点。 进行分区后不同的分区可以放在不同的机器上   
处理，每个节点都是可以独立处理查询的，这样的查询也是可以并行的。

**如何分区？**

    1. 按照键的范围分区
    2. 通过散列分区

先来看第一点：通过键的范围来分区。这种方式最容易让人想到的就是字典。一个大的字典是以A-Z为开头的一个集合。 我们可以 
将字典分为四个区域，分别是A - D， D - H, H - S, S - Z ，如果查询C 就直接去第一个分区查询，这种方式的好处是查询的这个范围
是有序的，查起来会很容易。 
但是很多时候是无法很好的确定分区的这个数据是比较平衡的，这个需要动态的去调整。

第二点，散列分区： 这种方式的好处是让数据能够进行平衡分布，减少热点。但是数据不再有范围。

散列分区这种方式可以减少热点的存在，但是如果热点只有一个，同一个时刻有大量请求到一个热点里也可能照成系统出问题。
一个方式就是将这个请求打散，在这一个单独的热点后再加两位随机数，将这个放在不同的主键里。这也称为**热点消除**

**分区再平衡**

数据库的数据是不会总保持不变的。 查询的吞吐可能会增加，数据可能会变得更大，机器可能出现问题。
将负载从一个节点变到另一个节点的过程就是**再平衡**，1.通过再平衡后要做到读写操作的压力在集群上是
公平的分享的。2.在平衡的过程中不应该影响系统的使用。3.只对有必要进行移动的数据进行移动。

**平衡的策略**

* hash mod n 

**要尽量将散列分成不同的范围来使用。**  如果使用**mod**的方式，如果mod 的n的数量变化，大量的key
都需要重新移动。这种开销是非常大的。

解决的办法： 分配比节点更多的分区，给每个节点分配分区。 如果要添加新的节点，就把旧节点中的分区
拿出来一点到新的节点。这个只改变的是分区所在的节点。在变更的时候，原有的节点是可以继续使用的。

虽然一开始可以选择足够多的分区， 但是每个分区都是很大的，分区在移动的时候开销会很大，如果分区的很小的，
管理这些分区也会有很多开销。如果分区的数量固定下来，数据的变动很大，开销也会很大。

**动态分区**

如果是使用按照键的范围来分区的话，分区的边界和数量固定下来是非常不便的。
考虑到这一点，在一些数据库的实现中会动态创建分区，当一个分区的数据大小超过某个值，就自动将该分区变为
两个分区，每个分区有之前一半的数据量。如果数据缩小到某个值以下，相邻分区则会合并。

另外需要考虑到的一点是刚开始的时候没有数据，到达设置的值才会开始进行动态分区。所以一开始的时候压力都是
落在一个节点的。要解决这个问题就需要预先分割数据，一开始就把数据落在不同的地方。

**按照节点比例分区**

动态分区的时候，分区数量和数据集大小是成正比的。固定分区的时候也是如此。 但是这两种方式都和节点数量无关。

另外一种方式是节点和分区数量是成正比的。 新节点加入的时候随机选择固定数量的现有分区进行拆分，将每个分区中
的一般负载到新的节点。使得整个系统的负载是均衡的。


**如何找到数据所在的节点？**

现在的数据是在多个节点上的，客户端一个请求后发生后，如何找到正确的节点？ 而且分区会重新平衡，节点会增加。
**服务发现**

这种问题有三种方式来解决。

* 客户端不关心在那个节点，随机请求一个节点，这个节点去找相应的数据，找到后返回这个数据。
* 在客户和节点中添加一个路由层，这一层负责请求和转发。
* 客户端知道数据在那一个节点，请求的时候直接请求对应节点。


**一致性哈希算法**

上面提到了普通的取模的哈希的缺点。如果取的这个数字发生了变化，则hash后的值可能会产生大的改变，偏移会变很多。

一致性哈希算法主要就是解决这个问题的。
思路是配置一个 0-2*32（常用的是这么大）圆，将节点映射在这个圆上，寻找数据的时候按照顺时针来寻找，这时如果有新的
节点填入影响的范围也是很小的。 这时有一个问题是有三个节点，映射在圆上的位置并不好，可能会造成数据倾斜问题。
导致某一个节点的压力过大造成系统不可用。 解决这个问题的办法是虚拟节点，通过分配很多节点均衡的分布在圆上，从而
控制压力不会只落在几个节点上。
 