### 设计数据密集型应用。

**现在很多应用都会有大量的数据产生，以往的瓶颈主要是在cpu 和 io。现在随着数据越来越多，处理数据
成了主要的难点。 这本书主要从整体上来讲了各个点，主要是一本面向广度的书。 用来理解现在出现的这么多
工具的原理，以及要解决的问题。 作者在前言讲到现在出现了很多技术，比如消息队列，缓存，搜索索引，     
批处理的工具 流处理的工具。很多时候做的事情就是将合适的工具组合起来。要理解这些工具的原理，     
明白什么时候该用什么是非常重要的。**

正好最近对公司的很多东西有很多的疑问，正好碰到了这本书。 争取看完理解个30%。

本书的第一部分 主要讲了原理，数据系统的本质。 第二部分讲了分布式的数据。第三部分讲了集成这些工具。
有很多的工具提供了很好的抽象，使我们使用的时候不用关心太底层的东西。但是想用好是很难的，熟悉了原理才可以用起来得心应手。 比如 数据库， 改用sql    
的还是mysql的？现在很多的应用都是需要很多组件来组合起来的，
区分好不同工具是很重要的。

在将不同的工具组合起来后我们向外提供了一个接口，这个接口把应用背后的细节都隐藏了，只提供应用功能。

很重要的三点：

* 可靠性
* 可扩展性
* 可维护性

#### 可靠性
1.   是否实现了预期的功能
2.   由于应用是给人用的，是否能容忍用户的一些错误的行为
3.   系统是否能够抗住预期的压力
4.   系统是否可以防止未经授权的行为。

以上几点都做到就是一个可靠的系统。


可能出现的错误叫故障，如果一个系统是可以发现错误并处理的就叫弹性或者容错。
有的组件出现错误可能是只影响一部分功能，有的就会直接导致整个服务不可用。需要通过一些手段来在不可靠的系统上提供可靠的服务。（这一点和网络很像）
为了测试容错的好坏，可以选择随机干掉一些正常的进程来增加错误率，用来看容错系统是否足够好用。
对于一些问题就需要尽可能的预防了，比如安全问题。

##### 硬件错误

内存会失效，硬盘会坏掉，网线会被挖断。。 这种情况在比较大的场景下很容易出现， 如何保证硬件坏了的情话下服务还可以用？ 这一点主要就是依靠 冗余。   
一块硬盘挂掉另一块的还可以用（RAID）。

关于硬件的话现在云服务已经很火了。这方面需要担心的事情并不是特别多。主要还是要担心软件的故障。

##### 软件错误

软件的错误和硬件的错误的很大的一点区别就是 硬件错误影响的是一个点，而软件错误很可能会影响一个面。
举例来说就是 一个机器上的硬盘坏了它并不会影响另一台机器。但是如果是软件的话可能这里出现bug 会导致一串的问题出现。而且软件的问题相对来说要比硬   
件难检查很多，主要是因为预料不到的情况会非常多。

举例来说

 操作系统中可能会出现的一些bug
 不受控制的应用会占用很多其他资源，比如 cpu 内存 磁盘 网络等。
 上面提到的，一个地方出了bug影响了一整片程序。

通过尽可能全面的测试，进程隔离，运行进程尽早崩溃 重启，对系统有一个好的监控来尽早发现问题。

##### 人的错误
 
在整个系统中人是最不可靠的，要通过一些手段来减少这种错误。
设计系统的时候将错误最小化， 通过一些自动化工具来执行一些操作。使人的操作尽可能简单不容易出现问题。
通过一个完全模拟的测试环境来进行一些测试。
做好测试，从单元测试 到 集成测试 到手动的一些测试。 特别是考虑好哪些边界条件。
设计一些方法使得错误操作后可以立马恢复。 比如迅速回滚。
足够好的监控，使能尽早发现问题。
对人做好培训。

可靠性这一点是基石，有很多时候直接会损失很多钱。 当然有很多时候这一点并不是最重要的时候，比如要快速推出新的业务的时候，要快速实现功能的时候，  
这个时候就要做好权衡了。


#### 可伸缩性

这一点讲的应该是和之前看的《大型网站技术架构》中的一些东西一样。 主要都是讲一个应用是如何从一个小的扩展到一个大的。

这个概念主要是用来描述系统应对负载增加的能力。主要考虑的一个问题是如果系统按照一种方式来增长，
我们如何来应对。

#### 负载

不同的系统的负载不同，可能是web服务的qps， 数据库中的读写比，聊天服务器的活跃用户数量等。

作者用推特来举例
12年11月 
平均发推特的压力是 4.6k/s 高峰是12k/s 
看推特的压力是 300k/s

如果只是很简单的处理 12k/s 的写入操作是很容易的，难就难在这种应用是有很多的关系，一个人可能有很多的粉丝。 如果一个人发送了一条消息要让所有的粉    
丝都读到，考虑到这些的时候问题就开始麻烦了。（微博和推特应该也是类似的）


**第一种思路**

 直接在发帖的数据库中写。 发帖很简单。但是去看帖的话会麻烦一点。 而随着应用的发展，看帖的用户是远远高于发帖的用户的，进行大量的查询操作不仅处理    
 起来很麻烦，效率也不会特别高。在扩展的时候 这种方式就很难处理。

**第二种思路**  

  每个人维护一个收件箱。 看帖很简单。 这种思路的问题是有很多大v，粉丝特别多。如果按照这种方式来处理         
  会很困难，试想一个大v发了一个消息，要把这些消息推送到每个被关注者的收件箱里面，这样的话操作会很痛苦，扩展也很难。  （一个人平均75个关注者，   
  平均4.6k个写操作，用这种方式就变成了75*4.6k 的写入）

**第三种思路**

采用一种折中的方式，如果是大v 就使用第一种方式，否则使用第二种。


#### 性能

在描述一个系统的负载的时候作者给了以下两种方式：

增加负载的时候系统资源不变对系统的性能有什么影响？ 

    对于这种不同特性的系统是不同的，通过多个维度的监控可以看到想要的结果。 可能是cpu跑满了，可能是内存没了，可能是网卡缓存不够 等很多原因。

增加负载的时候应该增加多少资源才能保证系统的性能不受影响？

    对于这种来说很多时候不是来了两倍用户，单纯的增加两倍性能的机器就能解决的，还需要一些配套的机制来实现。    

作者区分了下延迟 和响应时间的区别

**延迟一般指的是网络的延时， 响应时间则包含了延时，还有任务处理的时间。**

在一个系统中，即使多次进行重复的请求得到的响应时间也是不一样的，在计算的时候不能简单的将所有的响应时间拿出来，然后很简单的计算平均值。 试想一种情况，     
A 用户进行一个请求 响应时间是1ms， 另一个用户请求 响应时间是 1000ms ，平均值就是500左右。 如果按照这种方式来统计是肯定不行的。所以在统计的时候    
要按照百分比进行统计， 比如 1-20ms 的占 80％，20 - 40 占10％ 剩下的占 10％。 按照这种方式拿到的数据会更准确点。 如果有99％的用户的响应时间    
都是在理想值以内的。那么没有特殊情况发生的时候去优化那1％不是特别值得的。 总之就是要去达到那个100，越到100的时候所需要耗费的越多，在一些方面上也就越不值得。
但是有一些时候是对一个用户后面对应的是很多模块，要分别统计这些响应时间，这个时候一些占比小的 但是延迟很大的就很有影响。因为这些响应耗时的不处理完，    
一个响应就无法真正完成，考虑的时候也要考虑这些东西。

在做一些负载测试的时候，尽可能模拟真实世界的情况。比如 在请求的时候等待上一个请求完再去进行下一个请求，这样就人为地控制了测试的时候的队列是比实    
际情况短的，测试也就不是那么准确。


对于大规模的系统它们的瓶颈都是特定的，没有一种很通用的方法。 作者在这里举了一个例子。 
100k/sec  每个请求1kb大小 和 3/min 每个请求2gb 大小  在吞吐量上面是相同的，但是实现的方案根本不同，我觉得作者想说的是设计的时候要把握到系    
统的主要特点，按照这一点来设计。 


水平扩展

  将应用放在多台机器上，提升性能和可用性。
   要求 服务器应该是无状态的。
   配套的下游服务器也必须跟着扩展。
   
垂直扩展

 将应用放在更加强大的机器上。

SLO 和 SLA

SLA 指的是 服务等级协议，主要是约定了服务类型，质量等东西。 比如 带宽大小，可靠性 99.9 ，相当于
SLO + 后果。
SLO 指的是 服务等级目标， 主要就是服务的期望的状态，比 qps 10k/s 还是 100k/s 等这些具体的指标。





可维护性

作者在一开始就给出一个观点，这个观点应该是大多数人都默认的。即开发一个系统的时候写代码不会花费多长时间，花费时间的是维护系统，修bug。 如果一个   
系统在设计之初没有设计好后面的维护是很痛苦的。而且大家都很讨厌维护旧的系统。

在看书之前思考下，所谓的可维护性就是要做到问题容易发现，发现了容易解决。 一个很重要的一点是设计的程序要尽可能做到低耦合，这样在修改的时候才不会    
因为一个点修改了影响整个系统。 同时有足够多的日志也是很重要的，有足够多的日志就意味着有足够多的线索去发现问题。 最后有一套统一的规范很重要，    
不仅大家合作写的时候写的舒服，维护的时候也不会看代码看吐了。尤其是 动态语言，语言给的约束已经很少了，再不嫁一些规范到后期就根本没法搞了。

作者说了几种方法。

可操作性
  使系统可以很简单的操作就运行的很流畅。
  作者在这里主要提到以下几点
*  监控好系统的运行状态，并且在系统挂了的时候能很快恢复。
*  跟踪问题，找到问题的根源
*  保证系统及时更新，并打了补丁
*  预见问题，并解决问题（比如 容量规划）
* 用好部署 配置 管理的工具（这里应该主要就是指运维自动化）
* …...
通过工具的介入，让很多的操作变得简单，可以把精力放在更重要的事情上。
* 写好文档，说明可能有问题的情况。
* 对整个系统提供监控
* 。。。。。


##### 简单性

   用尽可能简单的方法来解决问题，在代码这块就是该抽象出来的函数抽象出来，保证代码可以很简单的读懂。

##### 管理复杂度

  这块sicp讲了很多，可能写个几百行，一两千行的代码遇不到这种问题，但是随着功能越来越多，代码越来越多，不通过一些机制来保证程序就脱离的控制范围。

  这本书上也主要讲的是这些， 模块耦合，来回各种依赖，命名不规范等。。。
  但程序因为复杂性维护困难的时候，并不是增加时间投入就能获得很好的效果。有很多时候程序有很多情况是没有考虑到的，有很多意想不到的问题，这种是最烦的。   
   保持简单是系统的关键目标。简单不意味着功能就少了，主要是通过抽象来解决问题。说到这里又回到了sicp讲的内容。 很多东西果然都是相通的。 通过一个   
   好的抽象也就意味着在写程序的时候不用考虑很多问题，可以专注于解决当前的问题。 整个计算机学科中最重要的概念之一也就是抽象。



##### 可扩展性

   主要指系统在扩展功能的时候能够很简单扩展，不用考虑过多的问题。 这里可以想到的做的特别好的一点是flask，作者在设计的时候只设计了核心功能，   
   提供插件化的机制，便于将各种插件集成到框架中，并且这种集成是很高效的，不存在这个插件集成进来 但是影响另一个程序的情况。


新的业务会出现，新的工具会出现，如何把这些组合起来？这里就指的是可扩展性。

**敏捷开发？**  

测试驱动开发 和 重构。

总结，一个系统必须满足功能需求，和其它需求（高可用，可扩展，可维护）才能正常运行，本章主要提到了这些技术点。为什么要保证这些？ 可靠性就是在各种    
错误下系统仍然可以对外提供服务。可扩展性指的是负载增加的时候也可以保证系统很好的运行，上面用一个twitter的例子来引出这一点。 可扩展性主要就是做好抽象。
















.
