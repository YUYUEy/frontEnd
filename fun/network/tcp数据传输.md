#### tcp头部  

以太网首部 - IP首部 - TCP首部 - 应用数据

首先来明确下tcp要做的一些事情，从上面这句话可以看到是一层层封装的。在网络层次结构中，只需要关心  
上层和自己临近的一层。ip层为我们提供了主机和主机间的不可靠链接。 tcp需要提供的就是应用进程间的可靠  
链接。 为了提供具体的应用进程间的链接，使用了16位的端口号。（A的ip，端口， B的ip，端口）构成了一个四元组  
用来标识唯一的一个链接。 由于tcp是面向流的，tcp用32位的序列号和确认号 来标识。 用4位来标识首部长度  
还需要几位的标志位 来标识各种状态。 tcp是可以控制流量的，这个靠窗口来实现。 并且tcp是要对整个报文进行校验的  
以上就是tcp中主要要了解到的字段。 

![tcp头](http://pyblog-10073407.image.myqcloud.com/postimage1511277046)

#### tcp可靠传输原理  
简单来说tcp的可靠传输就是请求确认。但是这种方式的效率太低了，在tcp中通过滑动窗口的机制进行了一个高效  
数据传输

![win](http://pyblog-10073407.image.myqcloud.com/postimage1511616411?imageView2/0/w/450/h/400)  

如上图  
当窗口从左边沿向右靠近的时候，窗口合拢。这种现象发生在数据被发送和确认时。  
当窗口从右边沿向右移动，允许发送更多的数据。这种现象是接收方已经确认了数据，并释放了接收的缓存。  
当左边沿向左移动，这个是窗口收缩。很少有人这样子用。    

![wincontrol](http://pyblog-10073407.image.myqcloud.com/postimage1512484879?imageView2/0/w/450/h/400)  

tcp是一个全双工的协议，在两端都需要维护序号。  
一个有效的需要要满足  
snd_una < 确认序号 <= snd_max    
通过维持序号来保证两端的状态。  

#### push标志  
之前分析一个网络包的时候发现所有的网络包都有push标志。这个标志的含义是尽快把数据  
交给应用处理。 不加这个的话可能导致数据在缓存中待一段时间，这对于有实时性要求的应用来说  
是一个不好的机制。所以就通过push标志来解决。
  
#### tcp 拥塞控制  

发送窗口的上限 min[rwnd, cwnd] 选取拥塞窗口和接收窗口的的最小值。  
rwnd > cwnd的时候， 证明当前网络是主要瓶颈  
反之代表 接收方的接收能力是主要瓶颈。  

##### 慢启动和拥塞避免

当一个tcp链接建立的时候，该链接的cwnd先被置为1，然后变为2，经过每一个传输轮次cwnd进行指数增大。  
到达一个点的时候数据就开始出现丢包（这里的丢包包括 拥塞丢包和错误丢包）。 这是就通知发送方，  
将窗口变小。  

拥塞避免算法是cwnd每一个传输轮次加1（这里用1是为了理解，实际上cwnd是以字节为单位），而不是指数级别的  
增加。上面的算法之所以叫慢开始算法的原因是因为cwnd是从1开始的，而不是说增长的慢。  


这里还要有一个慢开始门限，用法如下：  
    
    cwnd<ssthresh 慢开始算法  
    cwnd==ssthresh 慢开始 或者 拥塞避免
    cwnd>ssthresh 拥塞避免

#### 快重传和快恢复。  

上面说到了慢启动和拥塞避免。现在来思考两种情况，当网络中某个报文在发送方设置的定时器时间内还没有  
到达，就任务网络出现了拥塞，将拥塞窗口变为1，同时慢开始门限变为之前的一半。这时由于拥塞窗口被直接减  
为1，网速会突然变低。  

使用了快重传的过程如下：  
1.收到三个重复的ack，将ssthresh变为当前拥塞窗口的一半（乘法减小）+3倍的报文段的大小（因为中间的三个报文是  
不占用网络资源的，重传的那个报文在发送方的内存中）。    
2.下一个新的ack被确认后，将cwnd变为ssthresh，然后继续采用拥塞避免。（快恢复）  

整体思路就是避免拥塞窗口突然变得很小，导致各种问题。  




#### 传播时延 和 发送时延  

传播时延主要是光速，传输设备等待时间，主要和距离有关系。  
发送时延主要是看带宽。  

带宽越大 传播时延影响就越大，反之则是发送时延影响大。  

**带宽时延乘积**  
把网络想像成一个水管，水管中可以容纳的谁的多少就是水管截面大小*水管长度。  
在网络中这个长度就是rtt，截面就是带宽。  
带宽时延积=往返延迟*链路带宽  

**长肥管道**  
长肥管道指的就是那些带宽时延积很大的网络。主要有几个问题：  

  **对于长肥管道，需要更大的窗口来提升吞吐。**  
  ：通过在tcp首部的选项中定义一个16bit的扩大操作可以加大窗口。  
    
  **一个长肥管道内的报文丢失会使得网拥塞窗口收敛到很小（尽管有快重传快恢复还是不能更好得解决问题）**  
  ： 见下面的bbr算法  
  **需要更好的rtt测量**  
   ： 见下面的bbr算法  
  **序号是32位的，网络可能很快就产生了回绕，相同序号可能在不到一个msl中就被重复使用（这里的问题和timewait哪里的有点区别）  
  这里的问题主要是如何保护回绕的序号。**
  
  PAWS算法，主要思路就是接收方维持一个时间戳，由于这个值是递增的，如果重发的数据在网络上又出现了，检查它的时间戳，发现比  
  当前时间小，直接丢掉。
  

**拥塞**  

当数据在一个大的管道进入一个小管道就可能出现阻塞。这就像从水桶往漏斗中灌水一样，最可能出现瓶颈的地方就是瓶口  
在网络中指的就是路由器了。当然这只是一种情况，网络时特别复杂的，还有很多情况会导致阻塞。  



#### bbr算法  

拥塞控制的本质问题就是估计当前网络最大的可承载量，找到一个点，整个网络的最大可处理的数据最多的那个点。  

上面提到的拥塞控制的算法的思路都是往网络中不断增大发送的数据包，直到到达一个瓶颈（这个瓶颈就是丢包的那个点  
这里不考虑错误丢包和拥塞丢包，在一些错误丢包多的环境下，这种算法就会出现问题，从而导致资源被浪费）。  

还有就是网络的缓存区膨胀问题。网络中有很多的buffer，会把数据buffer在网络中，这就导致了两个问题;  
1.buffer中等的数据越多，要等的时间会越长，延时会增加  
2. 缓存区被填满可能丢包。  
  
bbr算法主要是通过估计带宽和延迟估算网络容积，并且不去考虑丢包。  

https://www.zhihu.com/question/53559433








#### 什么时候用tcp 什么时候用udp？  

实时性，公平性，带宽 这三点是无法同时满足的。  
UDP也可以实现可靠传输，这种方式放弃了公平性（没有拥塞控制）增加了实时性（不需要三次握手  
来建立链接。）  
在实时性要求高的场合使用udp比较好，比如实时聊天。  
其它一些场合使用tcp，tcp是可以充分利用带宽的。比如 传输文件。。。    



#### 带宽换延迟？    

首先要明白tcp是为了流量设计的。

kcp https://github.com/skywind3000/kcp    

##### 思路：   

选取更合理的RTO。 tcp的rto每次超时就翻倍。 将这个值可以适当减小点。   

选择性重传，只重传丢掉的。   

快重传  发送端发送了1,2,3,4,5几个包 收到3 知道2被跳过一次，收到4 知道跳过了两次，立马重传2    
       
延迟ACK vs 非延迟ACK：   

TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用，主要是因为tcp会buffer掉一些数据，将这个累积到一个比较   
大的值进行发送。以提高利用率），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程。KCP的ACK是否延迟   
发送可以调节
 















